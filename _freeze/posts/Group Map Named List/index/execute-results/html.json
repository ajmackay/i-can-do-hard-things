{
  "hash": "ea759c849de722bfdefc282d01fcd536",
  "result": {
    "markdown": "---\ntitle: \"Named Lists from Group Maps\"\ndate: \"2023-12-12\"\ncategories: [iteration, purrr, map]\nimage: \"image.jpg\"\neditor_options: \n  chunk_output_type: console\n---\n\n\nThe <code>group_map()</code> function is one of my favourite iterative functions within the <code>purrr</code> package. Like the other iterative functions within the purrr-verse, it has been designed to be simple and intuitive.\n\nIn a nutshell, <code>group_map()</code> applies a function over each group of a grouped dataframe and returns a list containing the function result per group. This is great when we want to...well apply a function on a per group basis.\n\nAs a quick example, say we want to run a regression to pedict petal length with petal width for each class of species using data in the <code>iris</code> dataset. A <code>group_map()</code> will allow you to do this, and save the outcome in one object so that you can quickly access each regression outcome.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(purrr)\n\niris_df <- datasets::iris %>% as_tibble()\n\nlm_formula <- formula(\"Petal.Length ~ Petal.Width\")\n\nlm_results <- iris_df %>% \n  group_by(Species) %>% \n  group_map(function(dat, group) {\n    lm(lm_formula, data = dat)\n  })\n```\n:::\n\n\nAnd now we can quickly access our <code>lm</code> results by calling <code>lm_results</code>. Combining this with <code>broom</code>'s <code>tidy</code> in a <code>map()</code> means you can quickly see the key results of each regression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(lm_results, broom::tidy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)    1.33     0.0600     22.1  7.68e-27\n2 Petal.Width    0.546    0.224       2.44 1.86e- 2\n\n[[2]]\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)     1.78     0.284      6.28 9.48e- 8\n2 Petal.Width     1.87     0.212      8.83 1.27e-11\n\n[[3]]\n# A tibble: 2 × 5\n  term        estimate std.error statistic       p.value\n  <chr>          <dbl>     <dbl>     <dbl>         <dbl>\n1 (Intercept)    4.24      0.561      7.56 0.00000000104\n2 Petal.Width    0.647     0.275      2.36 0.0225       \n```\n:::\n:::\n\n\nHere you may notice the key issue for which this week's blog post is designed to address: How can you tell which result corresponds to which group?\n\nThe solution is reasonably simple: Create a list that contains the <code>lm</code> object and set the element names of the list to be the current group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_results <- iris_df %>% \n  group_by(Species) %>% \n  group_map(function(dat, group) {\n    model <- lm(lm_formula, data = dat)\n    \n    # Place the lm model into a list and set the name to be the current group\n    list(model) %>% \n      setNames(group$Species)\n  })\n\nlm_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[[1]]$setosa\n\nCall:\nlm(formula = lm_formula, data = dat)\n\nCoefficients:\n(Intercept)  Petal.Width  \n     1.3276       0.5465  \n\n\n\n[[2]]\n[[2]]$versicolor\n\nCall:\nlm(formula = lm_formula, data = dat)\n\nCoefficients:\n(Intercept)  Petal.Width  \n      1.781        1.869  \n\n\n\n[[3]]\n[[3]]$virginica\n\nCall:\nlm(formula = lm_formula, data = dat)\n\nCoefficients:\n(Intercept)  Petal.Width  \n     4.2407       0.6473  \n```\n:::\n:::\n\n\nAnd now you can see which <code>lm</code> model corresponds to which species group. However what this has done is added each named list element to the list that is created by <code>group_map()</code>. So while we can see in our output which element of <code>lm_results</code> contains which <code>lm</code> model, we cannot easily access these elements with the <code>\\$</code> operator, nor can we quickly iterate over each element like we could do previously.\n\nThankfully, the solution again is simple: if we use <code>flatten()</code> on our <code>group_map()</code> result, it will remove the nested layers that have in our list and put all the elements in one single layer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_results <- flatten(lm_results)\n\nlm_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$setosa\n\nCall:\nlm(formula = lm_formula, data = dat)\n\nCoefficients:\n(Intercept)  Petal.Width  \n     1.3276       0.5465  \n\n\n$versicolor\n\nCall:\nlm(formula = lm_formula, data = dat)\n\nCoefficients:\n(Intercept)  Petal.Width  \n      1.781        1.869  \n\n\n$virginica\n\nCall:\nlm(formula = lm_formula, data = dat)\n\nCoefficients:\n(Intercept)  Petal.Width  \n     4.2407       0.6473  \n```\n:::\n:::\n\n\nAnd now we all of our regression results packaged neatly into one, with each element clearly labelled as so:\n\n![](screenshot.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}